<!doctype html>
<!-- CURRENT TIME: about 22:10, want 20-25, feel free to ad-lib a LITTLE -->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Genetic Algorithms</title>

    <link rel="stylesheet" href="reveal/dist/reset.css">
    <link rel="stylesheet" href="reveal/dist/reveal.css">
    <link rel="stylesheet" href="reveal/dist/theme/black.css" id="theme">
    <link rel="stylesheet" href="genetic-algos.css">

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <div class="main-text" style="font-size: 1em">
            <h1>Tight Genes:</h1>
            <h2>Intro to Genetic Algorithms</h2>
            <h3>by Dave Aronson</h3>
            <h4>
              twitter.com/DaveAronson<br/>
              T.Rex-2022@Codosaur.us
            </h4>
            <h5>github.com/CodosaurusLLC/tight-genes</h5>
          </div>
          <aside class="notes">
            Hi everybody, I'm Dave Aronson, the T. Rex of Codosaurus, and . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 5em">üõ´ . . . üõ¨</div>
          <span class="slide-caption">Image: standard emoji</span>
          <aside class="notes">
            . . . I flew down here . . .
          </aside>
        </section>

        <section>
          <img src="images/pterodactyl.png" height="60%"
               style="position: absolute; top: 27%; left: 15%">
          <img src="images/chrome-offline-t-rex.png" height="35%"
               style="position: absolute; bottom: 35%; right: 35%">
          <span class="slide-caption">Images: https://pixabay.com/vectors/dinosaur-tyrannosaurus-t-rex-6273164/<br/>and https://pixabay.com/vectors/bird-flying-wings-dinosaur-ancient-44859/</span>
          <aside class="notes">
            . . . on my pet pterodactyl . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 10em">üë®üèΩ‚Äçüè´</div>
          <span class="slide-caption">Image: standard emoji</span>
          <aside class="notes">
            . . . to teach you about . . .
          </aside>
        </section>

        <section>
          <img src="images/genetic-testing.png" class="autofix" style="border-radius:1em">
          <span class="slide-caption">Image: https://pixabay.com/vectors/genetic-testing-gene-panel-genetics-2316642</span>
          <aside class="notes">
            . . . Genetic Algorithms!&nbsp;
            So what are genetic algorithms anyway?&nbsp;
            They are . . .
          </aside>
        </section>

        <!--

        <section>
          <img src="images/caution-sign.png" class="autofix">
          <span class="slide-caption">Image: https://vectorportal.com/vector/other-danger-vector-sign.ai/9045</span>
          <aside class="notes">
            But first . . .
            . . . a caveat.&nbsp;
            I am not an expert in Genetic Algorithms.&nbsp;
            I haven't used them at work, or for anything serious,
            but I looked into the concept,
            understood it (I think!),
            and saw it seems to be a lot simpler
            than its reputation implies.&nbsp;
            So I put together a pitch for a talk to explain it,
            and here I am!<br/><br/>
            Genetic algorithms are . . .
          </aside>
        </section>

        -->

        <section>
          <img src="images/settings_icon-icons.com_49925.png" class="autofix" style="background-color: white; border-radius: 1.03em">
          <span class="slide-caption">Image: https://icon-icons.com/download/49925/PNG/512/</span>
          <aside class="notes">
            optimization heuristics,
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 9em">WAT?!</div>
          <aside class="notes">
            Okay, optimization means
            finding a . . .
          </aside>
        </section>

        <section>
          <img src="images/army-reserve-captain-wanda-r-jewell-number-3-platform-from-redstone-arsenal-CROPPED.jpg" class="autofix">
          <span class="slide-caption">Image: https://picryl.com/media/army-reserve-captain-wanda-r-jewell-number-3-platform-from-redstone-arsenal-7f7d64</span>
          <aside class="notes">
            . . . better solution
            for something, ideally the best.&nbsp;
            And a heuristic is a . . .
          </aside>
        </section>

        <section>
          <img src="images/shortcut-through-the-dunes.jpg" class="autofix">
          <span class="slide-caption">Image: https://www.publicdomainpictures.net/en/view-image.php?image=205157</span>
          <aside class="notes">
            . . . shortcut to find a good solution to a problem.&nbsp;
            Heuristics are used because they are
            faster, simpler, cheaper,
            or in some such way less resource-intensive,
            than methods like
            precise calculation or
            brute-forcing your way through all possible values.&nbsp;
            However, heuristics are not guaranteed to find
            the actual best solution,
            only something good enough,
            for whatever value of "good enough"
            we care to apply.&nbsp;
            <br/><br/>
            There are many kinds of optimization heuristics,
            but genetic algoritms in particular,
            as you may have guessed from the name,
            are inspired by . . .
          </aside>
        </section>

        <section>
          <img src="images/Darwin-chart.PNG" class="autofix">
          <span class="slide-caption">Image: https://commons.wikimedia.org/wiki/File:Darwin-chart.PNG</span>
          <aside class="notes">
            . . . real-world biological evolution,
            primarily the principles of
            survival of the fittest,
            random combination of different sets of genes into a new set,
            and random mutation.

            <br/><br/>

            The history goes back to 1950, when . . .

          </aside>
        </section>

        <section>
          <img src="images/turing.png" class="autofix">
          <span class="slide-caption">Image: https://cdn.britannica.com/81/191581-050-8C0A8CD3/Alan-Turing.jpg</span>
          <aside class="notes">
            . . . Alan Turing,
            as in Turing Test, Turing Machine, Turing Completeness,
            the ACM's Turing Award, and so on,
            proposed a "learning machine"
            in which the mechanism of learning
            would be similar to evolution.&nbsp;
            However, simulated evolution didn't catch on much
            as a general approach
            until the 1960's and 70's,
            and still isn't very common.&nbsp;

            <!--
            The first commercial product,
            a mainframe toolkit for industrial processes,
            came out in the late 1980's, from General Electric.&nbsp;
            -->

            But it is occasionally seen, in the wild.&nbsp;
            Most famously,
            in 2005 NASA used a genetic algorithm to design an . . .
          </aside>
        </section>

        <section>
          <img src="images/st5-antenna.jpg" class="autofix expand-tall">
          <span class="slide-caption">Image: https://www.jpl.nasa.gov/nmp/st5/IMAGES/st5-antenna.jpg</span>
          <aside class="notes">
            . . . antenna for the ST5 satellites,
            launched in 2006.&nbsp;
            NASA's Jet Propulsion Laboratory's website says:
            "Its unusual shape is expected
            because most human antenna designers
            would never think of such a design."&nbsp;
            That is one of the great advantages of this approach.&nbsp;
            However, today we'll only be looking at
            much simpler problem domains.

            <br/><br/>

            The process of a genetic algorithm is a simple set of steps:
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="text-align: center">
              <tr><td colspan="9">Init</td></tr>
              <tr><td colspan="9"></td></tr>
              <tr><td colspan="9"></td></tr>
              <tr><td colspan="9"></td></tr>
            </table>
          </div>
          <aside class="notes">
            First, we create an initial population of candidates.&nbsp;
            In Genetic Algorithm lingo, these are called "chromosomes",
            but since most living beings contain
            <i>many</i> chromosomes in every cell,
            I don't like that term,
            I think it leads to confusion,
            so I'm just going to say "candidates".&nbsp;
            The next step is to . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="text-align: center">
              <tr><td colspan="9">Init</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr><td colspan="9">Assess</td></tr>
            </table>
          </div>
          <aside class="notes">
            . . . assess how "fit" each candidate is,
            according to whatever criteria we want to apply.&nbsp;
            Next we ask, are we . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="text-align: center">
              <tr><td colspan="9">Init</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td colspan="7">Done?</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . done?&nbsp;
            This could be based on the fitness,
            which is why we do it now,
            or other criteria, or a combination.&nbsp;
            If not, then next we . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="text-align: center">
              <tr><td colspan="9">Init</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td colspan="5">Select</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . select some candidates to breed the next generation, . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="text-align: center">
              <tr><td colspan="9">Init</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td></td>
                <td></td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . actually do the breeding,
            to create a whole new population . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="text-align: center">
              <tr><td colspan="9">Init</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr><td colspan="9">‚¨áÔ∏è</td></tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . mutate those new candidates, and . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td colspan="7"></td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . go back to step 2, assessing their fitness.&nbsp;
            This could be represented at a high level
            with some rather simple code, like so:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.75em">
            <pre>

how_many = 10  <span style="color:gray"># or however big we want</span>
pop = intial_pop(how_many)
evaluate(pop)
while not done?(pop)
  breeders = select(pop)
  pop = breed(breeders, how_many)
  mutate(pop)
  evaluate(pop)
end
            </pre>
          </div>
          <aside class="notes">
            Now let's take a closer look at what goes on in each step.
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td style="color: white">Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            First we create an initial population of candidates.&nbsp;
            But what is a candidate, and how do we create one?&nbsp;
            These are different solutions to some problem,
            usually represented as
            different instances of the same data structure.&nbsp;
            They could be
            objects of the same class,
            maps with the same keys,
            or anything else we want,
            so long as they can be
            evaluated to come up with a fitness level,
            and we can combine two (or maybe more!) old ones
            to make a new one.&nbsp;
            The simplest common type of candidate is . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: .75em">
            <b>
              <code>
                01001000<br/>
                01100101<br/>
                01101100<br/>
                01101100<br/>
                01101111<br/>
                00100000<br/>
                01110111<br/>
                01101111<br/>
                01110010<br/>
                01101100<br/>
                01100100<br/>
                00100001<br/>
              </code>
            </b>
          </div>
          <aside class="notes">
            . . . a simple string of bits.&nbsp;
            This will do fine for candidates that consist of
            a simple series of yes/no decisions.&nbsp;
            This may sound simplistic,
            but there is a huge class of problems that boil down to this,
            called . . .
          </aside>
        </section>

        <section>
          <img src="images/backpack.png" class="autofix">
          <span class="slide-caption">Image: https://publicdomainvectors.org/en/free-clipart/Rucksack-vector-image/9910.html</span>
          <aside class="notes">
            . . . knapsack problems,
            because they are computationally equivalent to
            The Knapsack Problem.&nbsp;
            So what is <i>that</i>?&nbsp;
            You have a knapsack --
            or rucksack, backpack, or whatever you call it --
            and many things you want to carry in it,
            but they won't all fit,
            or the total weight is more than you can carry,
            or some such similar constraint,
            or combination of constraints.&nbsp;
            So you want to find the combination of items,
            that will fit the constraints,
            and has the maximum value.&nbsp;
            That could be the literal cash value,
            like if you're a jewel thief,
            or something more metaphorical,
            like if you're literally putting items in a knapsack,
            to go on a camping trip, with the items of most usefulness.&nbsp;
            If we have only, say, three items,
            that's only eight combinations,
            so we can probably brute-force
            our way through the solution space
            pretty easily.&nbsp;
            However, each time we add a possible item,
            that doubles the number of combinations.&nbsp;
            So if we have ten items to consider,
            that's 1024 possible combinations,
            and not all of them might even fit.&nbsp;
            Suppose we know . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 9em">
            üßëüèæ‚Äçüåæ
            üöö
          </div>
          <span class="slide-caption">Image: standard emoji</span>
          <aside class="notes">
            . . . a farmer,
            with a smallish truck,
            and he needs to decide what to take to market.&nbsp;
            And on this farm he has . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 4em">
            üêÑ üêÑ üêÑ üêÑ
          </div>
          <span class="slide-caption">Images: standard emoji</span>
          <aside class="notes">
            . . . some cows, EIEIO!&nbsp;
            So among the things he can take to market are:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 4em">
            üêÑ
            ü•õ
            üßÄ
            üßà
            üç®
            ü•©
            <span style="background-image: url(images/leather.png)">&nbsp;&nbsp;&nbsp;<span>
          </div>
          <span class="slide-caption">Images: standard emoji plus https://www.rawpixel.com/image/6130389/</span>
          <aside class="notes">
            . . . cows,
            milk,
            cheese,
            butter,
            ice cream,
            meat,
            and leather.&nbsp;
            For the sake of simplicity,
            we won't differentiate between
            between price and profit,
            nor dairy versus meat cows,
            and it's very unrealistic but
            we'll assume that
            he can only take a set amount of everything.&nbsp;
            His truck has <i>room</i> to take all the items,
            but it can only carry so much <i>weight</i>,
            so that's our constraint.&nbsp;
            His choices are as follows:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="all-right">
              <tr>
                <th class="text">What</th><th class="text">Unit</th><th>Qty</th><th>Pounds</th><th>Value</th><th>$/lb</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="6"><hr/></td></tr>
              <tr>
                <td class="text">Cow</td><td class="text">cow</td><td>1</td><td>1,500</td><td>$2,000</td><td>$1.33</td>
              </tr>
              <tr>
                <td class="text">Milk</td><td class="text">1-gal jug</td><td>200</td><td>1,720</td><td>$800</td><td>$0.47</td>
              </tr>
              <tr>
                <td class="text">Cheese</td><td class="text">5-lb wheel</td><td>200</td><td>1,000</td><td>$12,000</td><td>$12.00</td>
              </tr>
              <tr>
                <td class="text">Butter</td><td class="text">1-lb block</td><td>1,000</td><td>1,000</td><td>$3,000</td><td>$3.00</td>
              </tr>
              <tr>
                <td class="text">Ice Cream</td><td class="text">1-gal tubs</td><td>200</td><td>1,000</td><td>$2,000</td><td>$2.00</td>
              </tr>
              <tr>
                <td class="text">Meat</td><td class="text">side</td><td>4</td><td>1,280</td><td>$8,000</td><td>$6.25</td>
              </tr>
              <tr>
                <td class="text">Leather</td><td class="text">hide</td><td>20</td><td>1,100</td><td>$6,000</td><td>$5.45</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            That all totals 8,600 pounds.&nbsp;
            But, his truck's suspension
            can only handle
            two tons, or 4,000 pounds.&nbsp;
            We could run through all the possible combinations,
            and see what totals the highest,
            or use a different very common heuristic
            of adding the most expensive thing that we can,
            over and over until we can't,
            but let's see what happens if we use a genetic algorithm.&nbsp;
            First we need a way to represent each candidate.&nbsp;
            In code, we could represent them as a class
            in a language such as Ruby,
            and create one randomly,
            or optionally with a passed-in value
            (as that will be handy later),
            like so:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
class Truckload
  def initialize(val=nil)
    @contents = val || rand(128)
  end
end</pre>
          </div>
          <aside class="notes">
            Whoa, that looks like we're just making a random number!&nbsp;
            That's right, we're making a random number
            <i>with seven bits</i>,
            meaning that we have a random 1 or 0
            for each of our seven possible items.&nbsp;
            We could get as complex as we want in this function,
            like dictating that we can have no more than
            a certain number of items,
            but there's not much else we can do to complicate this one.&nbsp;
            Many of the further functions are more amenable to complexity.

            <br/><br/>

            To create an initial population,
            we can just create a bunch of candidates
            and stuff them into an array, . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 2.2em">
            <pre>
  def self.initial_population(how_many)
    population = []
    for i in 1..how_many
      population.append(self.new)
    end
    return population
  end</pre>
          </div>
          <aside class="notes">
            . . . like so.&nbsp;
            (This could actually be done in much more idiomatic Ruby,
            so don't scold me for that,
            but I'm trying to keep it easily understandable by
            people who don't know Ruby.)
            So if we create a population of ten Truckloads,
            we might wind up with a list like this:
          </aside>
        </section>
        
        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="7"><hr/></td></tr>
<tr><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y</td></tr>
<tr><td>N</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr>
<tr><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr>
<tr><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td></tr>
<tr><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr>
            </table>
          </div>
          <aside class="notes">
            Now wait a minute,
            how did we get from random numbers to those combinations?&nbsp;
            Behind the scenes, that translation might look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.9em">
            <pre>
  class Truckload
    class Item
      attr_reader :name, :weight, :value
      def initialize(name, weight, value)
        @name   = name
        @weight = weight
        @value  = value
      end
    end
    ITEMS = [
      Item.new("Cow",       1500,  2000),
      Item.new("Milk",      1720,   800),
      Item.new("Cheese",    1000, 12000),
      Item.new("Butter",    1000,  3000),
      Item.new("Ice Cream", 1000,  2000),
      Item.new("Meat",      1280,  8000),
      Item.new("Leather",   1100,  6000),
    ]
  ...
  end</pre>
          </div>
          <aside class="notes">
            and we can iterate through the ITEMS list,
            checking whether the corresponding bit is on in our manifest.&nbsp;
            The next step is . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td style="color: white">Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . to
            assess how "fit" each of these truckloads is.&nbsp;
            We do this with what's called a "fitness function".&nbsp;
            Just like how biological creatures might be perfectly fit
            for one environment but a lousy fit for another,
            this should reflect how fit a candidate is
            <i>for some particular purpose</i>.&nbsp;
            In this case, we already know we want the total value,
            BUT, any load that's too heavy for the truck, is worthless.&nbsp;
            In Ruby, or any language with a ternary operator,
            that would look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1em">
            <pre>
  def fitness()
    weight =
      (0 ... ITEMS.count).
      map { |n| ((1 &lt;&lt; n) & @contents) &gt; 0 ? ITEMS[n].weight : 0 }.
      sum
    return 0 if weight > 4000
    (0 ... ITEMS.count).
      map { |n| ((1 &lt;&lt; n) & @contents) &gt; 0 ? ITEMS[n].value : 0 }.
      sum
  end</pre>
          </div>
          <aside class="notes">
            We iterate through the possible items,
            summing up the weights of the ones we want to take,
            determined by whether the corresponding bit is on
            in our list of contents.&nbsp;
            If that exceeds the truck's capacity, we return zero,
            else we use the same technique
            to sum up the <i>values</i> of those same items.

            <br/><br/>

            Once again,
            we could get as complex as we want in this function,
            and NASA's antenna fitness function
            certainly must have been.&nbsp;
            For instance, if we also had the <i>volume</i> of each item,
            and the truck were smaller,
            we could also total up the volume,
            and make sure it all fits.&nbsp;
            We could even take into account very long or flat shapes,
            so that for instance a flagpole might not fit,
            even though its weight and total volume may be relatively small.

            <br/><br/>

            Anyway, if we run this function on our population, we get this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
                <th>Fitness</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="8"><hr/></td></tr>
<tr><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td class="numeric">0</td></tr>
<tr><td>N</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td class="numeric">5,000</td></tr>
<tr><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td><td class="numeric">8,800</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td class="numeric">14,800</td></tr>
<tr><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td class="numeric">13,000</td></tr>
<tr><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td class="numeric">2,800</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td class="numeric">0</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td class="numeric">20,000</td></tr>
            </table>
          </div>
          <aside class="notes">
            Now that we know how fit each one is,
            the next step is to see if . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . we're done.&nbsp;
            So what are our criteria?&nbsp;
            The function can be simple,
            but it can take some thinking to figure out
            what the function should <i>do</i>.&nbsp;
            With a knapsack problem,
            a good solution can be made worthless by
            adding just one more item, exceeding the capacity.&nbsp;
            So, we're going to record the best we've seen,
            and stop if we haven't seen anything better
            within 100 generations.&nbsp;
            Why 100?&nbsp;
            Pretty much random.&nbsp;
            It seems like enough for a good chance for improvement,
            and since what we're doing is so simple,
            using lots of generations isn't very slow.&nbsp;
            In Ruby, that would look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.2em">
            <pre>
  @@best_combo  = self.new(0)
  @@generations = 0

  def self.done?(population)
    @@generations += 1
    candidates =
      population.
      select { |c| c.fitness > @@best_combo.fitness }
    return @@generations >= 100 if candidates.none?
    @@best_combo = candidates.sort_by(&:fitness).last
    @@generations = 0
    false
  end</pre>
          </div>
          <aside class="notes">
            When the code is initially parsed,
            we set the initial best combo as empty,
            and we set how many generations it's been since we saw that,
            as zero,
            both as class-variables.&nbsp;
            (Remember, this is within the definition of class Truckload.)&nbsp;
            When the function is called,
            we increment the number of generations,
            look at the fitness of each member of the current population,
            and select only the ones with a better fitness than
            the best one so far.&nbsp;
            If there are none,
            then we return true
            if it's been 100 generations since the best one,
            else we return false.&nbsp;
            Otherwise, we sort them by fitness,
            take the fittest one,
            and make that our new benchmark.

            <br/><br/>

            Again, we can get as complex as we want,
            with other stopping criteria,
            like also looking at the
            average or minimum fitness,
            or achieving some specific level of maximum fitness,
            or some number of generations in total,
            or some amount of time (whether clock time or CPU or whatever),
            or when the user presses a STOP button,
            or many other parameters,
            or a combination of ways.

            <br/><br/>

            Since we're not done, the next step is to . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . select some candidates to use in
            breeding the next generation.&nbsp;
            The obvious way is to take the top two scorers, like so:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
  def Truckload.select_breeders(population)
    population.
      sort_by(&:fitness).
      reverse.
      take(2)
  end</pre>
          </div>
          <aside class="notes">
            Take the population,
            sort them by fitness in descending order,
            and take the first two.&nbsp;
            Out of our current population, we would choose:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
                <th>Fitness</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="8"><hr/></td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td class="numeric">20,000</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td class="numeric">14,800</td></tr>
            </table>
          </div>
          <aside class="notes">
            these two.&nbsp;

            As usual, we also could get more complicated,
            like selecting two randomly
            with each candidate having a <i>chance</i> to be selected,
            proportional to their fitness,
            and lots of other ways.&nbsp;

            <br/><br/>

            We could also take more than two,
            whether to breed all pairs in that set
            or to combine more than two at once.&nbsp;
            Or we could combine strategies,
            such as using all trios from a randomly chosen five,
            with the fitter ones having a better chance to be chosen.

            <br/><br/>

            Now that we've chosen our breeders, next we actually . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . breed them.&nbsp;
            The usual way is called crossover.&nbsp;
            This consists of taking the data points,
            or in Genetic Algorithm lingo, the "genes",
            from one parent,
            up to some randomly chosen crossover point,
            then switching to the other parent.&nbsp;
            This can be extended with multiple crossover points,
            but we're just going to use one, like so:
            <!--
            There are also lots of ways we can combine <i>three</i> or more
            candidates into one new one.&nbsp;
            Another common way is to randomly decide
            which parent contributes which part of the data,
            -->
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.4em">
            <pre>
  def self.combine(p1, p2)
    cross_point = rand(ITEMS.count + 1)
    list =
      (0..ITEMS.count).
      map { |index|
        parent = index < cross_point ? p1 : p2
        parent.contents & (1 << index)
      }.
      sum
    return self.new(list)
  end</pre>
          </div>
          <aside class="notes">
            We establish the crossover point,
            as a random number
            between zero and how many items there are.&nbsp;
            Then we iterate through the list of items,
            by index number.&nbsp;
            If we haven't yet hit the crossover point,
            we get the decision for that item from the first parent,
            else we get it from the other parent.&nbsp;
            This means that it could be all copied
            from one parent or the other,
            or it could switch at some point.&nbsp;
            Doing the bitwise math like that
            gets us zero if the bit was off,
            and value of that bit if it was on.&nbsp;
            Then we sum them up.&nbsp;
            Doing this once,
            with a crossover point of 3,
            meaning we take 3 values from the first parent,
            gets us a result like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="7"><hr/></td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr>
<tr><td colspan="7" style="text-align: center">+</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td colspan="7" style="text-align: center">=</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
            </table>
          </div>
          <aside class="notes">
            But this is just one of ten results,
            because we're making a whole new population, like so:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.45em">
            <pre>
  def self.new_population(p1, p2, how_many)
    population = []
    for i in 1..how_many
      population.append(self.breed(p1,p2))
    end
    return population
  end</pre>
          </div>
          <aside class="notes">
            This is just like how we created the initial population,
            except that instead of each candidate being
            made from scratch,
            they're the product of breeding our chosen breeders.&nbsp;
            The whole list might look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="7"><hr/></td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr>
            </table>
          </div>
          <aside class="notes">
            Lots of family resemblance there, eh?&nbsp;
            None of these loads include a cow, butter, or leather,
            and they all include cheese.&nbsp;
            That's because our two breeders were like that.&nbsp;
            If we were to just continue
            breeding the fittest of this population,
            we wouldn't <i>ever</i> see any loads
            including a cow, butter, or leather,
            or not including cheese,
            but we fix that in the next step, which is to . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . mutate them.&nbsp;
            Again, I'm going to keep it very simple,
            and give each gene
            a 1 in 4 chance of flipping.&nbsp;
            In code, that looks like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.3em">
            <pre>
  def maybe_mutate()
    (0..ITEMS.count).
      each { |index|
        if rand(4) == 0
          @contents ^= 1 << index
        end
      }
  end</pre>
          </div>
          <aside class="notes">
            We iterate through the item numbers,
            and for each one,
            if a random number from zero to three is a zero,
            we flip that bit, by x-or-ing it.&nbsp;
            Again, we could get as complex as we want,
            like having some genes more likely to mutate than others,
            or having some minimum or maximum
            number of mutations per candidate,
            or all kinds of other options.&nbsp;
            If we run this mutation function
            on the candidates in our new population,
            we might wind up with something like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="7"><hr/></td></tr>
<tr><td>N</td><td class="changed">Y</td><td class="changed">N</td><td class="changed">Y</td><td class="changed">N</td><td>N</td><td class="changed">Y</td></tr>
<tr><td>N</td><td class="changed">N</td><td>Y</td><td class="changed">Y</td><td class="changed">N</td><td>N</td><td>N</td></tr>
<tr><td class="changed">Y</td><td>N</td><td>Y</td><td class="changed">Y</td><td>Y</td><td class="changed">Y</td><td>N</td></tr>
<tr><td class="changed">Y</td><td class="changed">Y</td><td>Y</td><td class="changed">Y</td><td class="changed">Y</td><td>Y</td><td>N</td></tr>
<tr><td class="changed">Y</td><td class="changed">Y</td><td>Y</td><td class="changed">Y</td><td class="changed">N</td><td>N</td><td class="changed">Y</td></tr>
<tr><td>N</td><td class="changed">Y</td><td class="changed">N</td><td class="changed">Y</td><td class="changed">N</td><td>N</td><td class="changed">Y</td></tr>
<tr><td class="changed">Y</td><td class="changed">Y</td><td class="changed">N</td><td class="changed">Y</td><td>N</td><td>N</td><td class="changed">Y</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td class="changed">Y</td><td>N</td><td class="changed">N</td><td class="changed">Y</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td class="changed">Y</td><td class="changed">N</td><td>N</td></tr>
            </table>
          </div>
          <aside class="notes">
            I've colored the ones that changed, in green.&nbsp;
            You can see that we now DO have some truckloads that
            include a cow, butter, or leather,
            or omit cheese.&nbsp;
            Now we go back to . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td style="color: white">Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . Step 2, assessing the fitness of
            the candidates in this new population.&nbsp;
            If we sort on fitness descending,
            just to make it easy to find the best,
            we get this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
                <th>Fitness</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="8"><hr/></td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td class="numeric">15,000</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td class="numeric">14,000</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td class="numeric">14,000</td></tr>
<tr><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td class="numeric">9,800</td></tr>
<tr><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td class="numeric">9,800</td></tr>
<tr><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td class="numeric">7,000</td></tr>
<tr><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td class="numeric">0</td></tr>
            </table>
          </div>
          <aside class="notes">
            Oh noes!&nbsp;
            Our maximum fitness actually went <i>down!</i>&nbsp;
            But that's not too bad,
            as you may recall from our "are we done yet" function,
            we hang onto the best one,
            and just try to outdo it.&nbsp;
            So let's keep going.&nbsp;
            The next generation might look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
                <th>Fitness</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="8"><hr/></td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td class="numeric">12,000</td></tr>
<tr><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td class="numeric">11,000</td></tr>
<tr><td>N</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">10,000</td></tr>
<tr><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td class="numeric">3,000</td></tr>
<tr><td>Y</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td class="numeric">0</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td class="numeric">0</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td class="numeric">0</td></tr>
            </table>
          </div>
          <aside class="notes">
            Still going down, oh no!&nbsp;
            But the one after that might look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
                <th>Fitness</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="8"><hr/></td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td class="numeric">20,800</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td class="numeric">20,000</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td class="numeric">20,000</td></tr>
<tr><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td class="numeric">14,000</td></tr>
<tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td class="numeric">12,000</td></tr>
<tr><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td class="numeric">2,800</td></tr>
<tr><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
<tr><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td class="numeric">0</td></tr>
            </table>
          </div>
          <aside class="notes">
            . . . a small improvement over our prior best!&nbsp;
            <i>This</i> is why we don't give up so easily.&nbsp;
            If we let this run to completion,
            we might wind up with something like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 0.8em">
            <table class="centered">
              <tr>
                <th>Cow</th>
                <th>Milk</th>
                <th>Cheese</th>
                <th>Butter</th>
                <th>Ice Cream</th>
                <th>Meat</th>
                <th>Leather</th>
                <th>Fitness</th>
              </tr>
              <tr style="font-size: 0.1em"><td colspan="8"><hr/></td></tr>
              <tr><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td class="numeric">26,000</td></tr>
              <tr><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td class="numeric">21,000</td></tr>
              <tr><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td class="numeric">10,800</td></tr>
              <tr><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td>Y</td><td class="numeric">8,000</td></tr>
              <tr><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td><td class="numeric">8,000</td></tr>
              <tr><td>N</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td class="numeric">5,000</td></tr>
              <tr><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td class="numeric">8,00</td></tr>
              <tr><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td class="numeric">8,00</td></tr>
              <tr><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td class="numeric">0</td></tr>
              <tr><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td class="numeric">0</td>
            </table>
          </div>

          <aside class="notes">
            Actually, that that top line there,
            with just cheese, meat, and leather,
            is the best combination
            I've ever seen this particular system produce.

            <br/><br/>

            Now, suppose we want to evolve . . .
          </aside>
        </section>

        <section>
          <img src="images/something-completely-different.jpg" class="autofix">
          <span class="slide-caption">Image: https://image.tmdb.org/t/p/w500/ajbdFQLvJTlNu4LnVWGnNMb4mZ8.jpg (used for edu fair use)</span>
          <aside class="notes">
            . . . something completely different.&nbsp;
            Suppose we want to "evolve" a good set of stats for a
            Dungeons and Dragons fighter character,
            so our candidates are sets of stats.&nbsp;
            My DnD knowledge is rather out of date,
            I haven't played in about thirty years,
            but back in my day, character stats were . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1em">
            <div style="display: inline-block; text-align: left">
              STR<span style="color: gray">ength</span><br/>
              INT<span style="color: gray">elligence</span><br/>
              DEX<span style="color: gray">terity</span><br/>
              CON<span style="color: gray">stitution</span><br/>
              WIS<span style="color: gray">dom</span><br/>
              CHA<span style="color: gray">risma</span><br/>
              <br/>
              3d6 each<br/>
              ignoring STR 18/xx
            </div>
          </div>
          <aside class="notes">
            . . .
            Strength,
            Intelligence,
            Dexterity,
            Constitution,
            Wisdom,
            and Charisma,
            each determined by rolling three six-sided dice,
            or 3d6 for short.&nbsp;
            (I'm going to gloss over
            how you can sometimes have extra strength.)&nbsp;
            In Ruby that might look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.9em">
            <pre>
class Character
  def initialize()
    @str = roll(3, 6)
    @int = roll(3, 6)
    @dex = roll(3, 6)
    @con = roll(3, 6)
    @wis = roll(3, 6)
    @cha = roll(3, 6)
  end
end</pre>
          </div>
          <aside class="notes">
            (Defining the roll function is left
            as an exercise for the watcher.)&nbsp;
            So if we create a population of ten Characters,
            we might wind up with a list like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha
 11    9    9   10    7   15
  4   14    8   12   13   10
  9   14   15   11    9   16
 14   15   10    7    6   14
 13   12    7   13   11   10
 12   12   10    9    5   16
 11   12    9   13    6   12
 10   14   12    8    8   16
 14    7    8    9    8    8
 14   12   13    5   13   13
            </pre>
          </div>
          <aside class="notes">
            The next step is . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td style="color: white">Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . to assess how "fit" each of these characters is.&nbsp;
            We're trying to evolve a good set of Fighter stats,
            so it should be based mainly on strength and constitution.&nbsp;
            Dexterity is also helpful.&nbsp;
            Intelligence, wisdom, and charisma, not so much,
            but we don't want them too low,
            for the sake of occasional saving throws.&nbsp;
            I toyed with a few different things, such as
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
  def fitness()
    str * 2 + con + dex / 2
  end
            </pre>
          </div>
          <aside class="notes">
            totaling up double the strength,
            the constitution,
            and half the dexterity.&nbsp;
            But, the other stats tended to get too low,
            and even the dexterity.&nbsp;
            So I tried . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.5em">
            <pre>
  def fitness()
    stats = [str, con, dex, int, wis, cha]
    (0..5).
      map { |idx| stats[idx] * (6 - idx) }.
      sum
  end
            </pre>
          </div>
          <aside class="notes">
            prioritizing them linearly,
            adding up six times the strength, five times the constitution,
            and so on down to one times the charisma.&nbsp;
            But then the other stats got too high,
            and the characters seemed too generalized.&nbsp;
            So I finally settled on this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.5em">
            <pre>
  def fitness()
    stats = [str, con, dex, int, wis, cha]
    (0..5).
      map { |idx| stats[idx] * 2 ** (5 - idx) }.
      sum
  end
            </pre>
          </div>
          <aside class="notes">
            . . . prioritizing the stats
            again but much more strongly,
            totaling up 32 times the strength,
            16 times the constitution,
            and so on down to one times the charisma.&nbsp;
            Here we see that
            even though the fitness function itself can be very simple,
            it can be difficult to figure out
            one that will yield good results.

            <br/><br/>

            If we run this on our population, we get this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha  Fit
 11    9    9   10    7   15  649
  4   14    8   12   13   10  476
  9   14   15   11    9   16  674
 14   15   10    7    6   14  726
 13   12    7   13   11   10  760
 12   12   10    9    5   16  682
 11   12    9   13    6   12  703
 10   14   12    8    8   16  632
 14    7    8    9    8    8  708
 14   12   13    5   13   13  719
            </pre>
          </div>
          <aside class="notes">
            But are we done?
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            What are our criteria?&nbsp;
            Let's say we're done if
            any candidates get 90% of the way to the maximum score
            of our fitness function.&nbsp;
            I'll spare you the math,
            but the maximum is 1,134, so 90% would round to 1,021.&nbsp;
            In code, that looks like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
  def Character.done?(population)
    population.any? { |cand|
      cand.fitness &gt;= 1021
    }
  end</pre>
          </div>
          <aside class="notes">
            None of our current candidates score
            anywhere near 1021, so we . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . select some candidates to use in
            breeding the next generation.&nbsp;
            Taking the top two scorers again we get:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha  Fit

 13   12    7   13   11   10  760

 14   15   10    7    6   14  726
            </pre>
          </div>
          <aside class="notes">
            these two.&nbsp;
            Of course the abstraction gets a bit leaky now,
            because we're ignoring sexes;
            we have no guarantee that they'll be a male and a female,
            as we're not even making that part of the data.&nbsp;
            We had the same leak last time, with the Truckloads,
            but then it was pretty obvious so I let it slide.&nbsp;
            Now that they're living beings
            (whether humans or elves or whatever),
            though, we could add such complications,
            and even add what race they are
            and bring in considerations of
            which races <i>can</i> breed together.&nbsp;
            Anyway, next we actually . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . breed them,
            this time using another common strategy,
            of essentially flipping a coin for each gene,
            like so:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.5em">
            <pre>
  def Character.breed(p1, p2)
    char = Character.new
    char.str = rand(2) == 1 ? p1.str : p2.str
    char.int = rand(2) == 1 ? p1.int : p2.int
    char.dex = rand(2) == 1 ? p1.dex : p2.dex
    char.con = rand(2) == 1 ? p1.con : p2.con
    char.wis = rand(2) == 1 ? p1.wis : p2.wis
    char.cha = rand(2) == 1 ? p1.cha : p2.cha
    return char
  end</pre>
          </div>
          <aside class="notes">
            We go through the stats one by one,
            flip a coin (or "roll a d2"),
            and if it comes up 1,
            we get that stat from the first parent,
            else we get it from the other parent.&nbsp;
            That could get us a result like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha
 13   12    7   13   11   10

              +

 14   15   10    7    6   14

              =

 13   12   10    7    6   14
            </pre>
          </div>
          <aside class="notes">
            This new character got the
            strength and intelligence of the first parent,
            and everything else from the second parent.&nbsp;
            This just happens to be
            the same results as the crossover method,
            if the crossover point happened to be
            between Intelligence and Dexterity.&nbsp;
            But again, this is just one of ten results,
            because we're making a whole new population,
            which might look something like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha
 13   12   10    7    6   14
 13   12    7   13    6   14
 14   12   10   13   11   14
 14   15    7   13    6   14
 13   12   10   13    6   14
 14   15   10    7   11   10
 14   12   10   13    6   10
 13   15   10   13    6   14
 13   15   10   13    6   10
 14   12    7    7    6   14
            </pre>
          </div>
          <aside class="notes">
            Lots of family resemblance there, again!&nbsp;
            For each stat, there are only two values,
            or in Genetic Algorithm terms, "alleles",
            for a total of 64 possible combinations,
            even less if any stats were the same between the parents.&nbsp;
            On average, these look much more suitable as fighters
            than the previous generation.&nbsp;
            (We'll figure their actual fitness scores later.)
            If we were to just continue
            breeding the fittest of this population,
            we wouldn't see any further improvement
            in the the values of each stat,
            but again, we fix that in the next step, which is to . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td>Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td style="color: white">Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . mutate them.&nbsp;
            <!--
              To do this, we need to determine how to determine
              whether a given stat gets mutated,
              and by how much.&nbsp;
            -->
            Again, I'm going to keep it very simple,
            and give each stat
            a 1/3 chance of staying the same,
            going up a point, or going down a point,
            within the valid range.&nbsp;
            In code, that looks like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.5em">
            <pre>
  def maybe_mutate()
    @str = maybe_mutate_stat(@str)
    @int = maybe_mutate_stat(@int)
    @dex = maybe_mutate_stat(@dex)
    @con = maybe_mutate_stat(@con)
    @wis = maybe_mutate_stat(@wis)
    @cha = maybe_mutate_stat(@cha)
  end

  def maybe_mutate_stat(stat)
    (stat + rand(3) - 1).clamp(3, 18)
  end</pre>
          </div>
          <aside class="notes">
            For each stat,
            we add a random number from 0 to 2,
            and subtract one,
            which is like adding a random number from -1 to 1,
            but we keep it within the range 3 to 18.&nbsp;
            Again, we could get as complex as we want,
            like giving it a higher chance of
            going up or down, maybe by multiple points,
            if it's very low or very high,
            to simulate the real-world phenomenon of regression to the mean,
            or all kinds of other options.&nbsp;
            If we run this mutation function
            on the candidates in our new population,
            we wind up with something like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha
<span style="color:#0f0"> 14</span>   12   10    7 <span style="color:#0f0">   7</span> <span style="color:#f33">  13</span>
<span style="color:#f33"> 12</span> <span style="color:#0f0">  13</span>    7 <span style="color:#0f0">  14</span>    6   14
<span style="color:#f33"> 13</span>   12   10 <span style="color:#0f0">  14</span>   11 <span style="color:#0f0">  15</span>
<span style="color:#0f0"> 15</span> <span style="color:#0f0">  16</span>    7 <span style="color:#0f0">  14</span>    6 <span style="color:#0f0">  15</span>
 13 <span style="color:#f33">  11</span>   10 <span style="color:#f33">  12</span> <span style="color:#f33">   5</span> <span style="color:#0f0">  15</span>
<span style="color:#f33"> 13</span>   15 <span style="color:#0f0">  11</span>    7   11   10
 14 <span style="color:#0f0">  13</span> <span style="color:#f33">   9</span> <span style="color:#f33">  12</span>    6 <span style="color:#f33">   9</span>
<span style="color:#0f0"> 14</span>   15 <span style="color:#f33">   9</span>   13    6 <span style="color:#0f0">  15</span>
 13   15 <span style="color:#0f0">  11</span> <span style="color:#f33">  12</span> <span style="color:#f33">   5</span> <span style="color:#f33">   9</span>
<span style="color:#f33"> 13</span>   12 <span style="color:#f33">   6</span> <span style="color:#f33">   6</span> <span style="color:#0f0">   7</span>   13
            </pre>
          </div>
          <aside class="notes">
            I've colored the stats that went up in green,
            and down, in red.&nbsp;
            Looking at the values in each column,
            you can see it's now much more diverse.&nbsp;
            Now we go back to . . .
          </aside>
        </section>

        <section>
          <div style="position: absolute; top: 25%">
            <table style="color: gray; text-align: center">
              <tr>
                <td>Init</td>
              </tr>
              <tr>
                <td>‚¨áÔ∏è</td>
                <td>‚ÜôÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td><center>‚¨ÖÔ∏è</center></td>
                <td>‚¨ÖÔ∏è</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="8">‚¨áÔ∏è&nbsp;&nbsp;‚¨áÔ∏è</td>
                <td>‚ÜñÔ∏è</td>
              </tr>
              <tr>
                <td style="color: white">Assess</td>
                <td>‚û°Ô∏è</td>
                <td>Done?</td>
                <td>‚û°Ô∏è</td>
                <td>Select</td>
                <td>‚û°Ô∏è</td>
                <td>Breed</td>
                <td>‚û°Ô∏è</td>
                <td>Mutate</td>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . Step 2, assessing the fitness of
            the candidates in this new population.&nbsp;
            If we sort on fitness descending,
            just to make it easy to find the best,
            we get this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha  Fit
 15   16    7   14    6   15  851
 14   15    9   13    6   15  815
 13   12   10   14   11   15  805
 14   13    9   12    6    9  785
 13   15   11   12    5    9  775
 13   11   10   12    5   15  757
 12   13    7   14    6   14  742
 14   12   10    7    7   13  715
 13   15   11    7   11   10  708
 13   12    6    6    7   13  635
            </pre>
          </div>
          <aside class="notes">
            Now we can see for sure,
            that this generation is much improved from the prior one.&nbsp;
            The old one ranged from 476 to 760,
            and the new one from 635 to 851.&nbsp;
            It's still nowhere near our stopping criterion of 1021,
            so fast-forwarding through six more rounds of
            selection, breeding, mutation, and assessment,
            we finally get one with good enough candidates,
            like . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha   Fit
 18   18    9   18    4   13  1029<span style="color:gray">
 18   17    7   18    6   14  1014
 18   16    8   18    3   13  1011
 18   15    7   18    3   13   999
 18   16    8   17    4   13   997
 18   16    6   18    3   15   997
 17   18    8   18    6   13   993
 17   16    9   18    3   14   988
 18   16    6   17    3   13   979
 17   16    8   17    4   12   964</span>
            </pre>
          </div>
          <aside class="notes">
            . . . this,
            <!-- ranging in fitness from 964 to 1029, -->
            with one suitable character
            having 18 Strength and Constitution,
            acceptable but sub-par Dexterity,
            and surprisingly high Intelligence.&nbsp;
            If we really wanted it more specialized,
            we could complicate the fitness function further,
            and do things like explicitly demand
            well above average scores
            in the class's needed stats,
            and forbid it to be so high in the others,
            or at least apply a penalty.

            <br/><br/>

            Now, let's suppose we don't need any more Fighters in the party,
            but now we need a Wizard.&nbsp;
            All we need to do is tweak our fitness function, like so:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.5em">
            <pre>
  def fitness()
    # below is the only line that changed!
    stats = [int, wis, dex, con, cha, str]
    (0..5).
      map { |idx| stats[idx] * 2 ** (5 - idx) }.
      sum
  end</pre>
          </div>
          <aside class="notes">
            . . . to prioritize intelligence first,
            then wisdom, dexterity, and so on,
            down to strength.&nbsp;
            An initial population would look roughly the same,
            since we haven't changed how that is generated, so
            I'll spare you those steps,
            but after 11 more generations
            I got this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Str  Int  Dex  Con  Wis  Cha   Fit
 12   18   17   12   15   18  1048
 14   18   16    9   15   16  1026
 15   18   15   10   15   16  1023<span style="color:gray">
 13   18   17   11   13   18  1013
 14   18   17   10   13   18  1010
 13   18   16    8   14   18  1009
 12   17   16   11   15   17  1002
 12   18   15    9   14   16  1000
 14   17   16   10   15   16   998
 14   17   17   11   13   18   982</span>
            </pre>
          </div>
          <aside class="notes">
            . . . containing three candidates 90% fit to be wizards.&nbsp;
            They're mostly pretty good in the other stats,
            but not so much as to be
            obviously better suited for some other class,
            except that that top one looks like a bard to me.

            <br/><br/>

            Remember though that this is all very random.&nbsp;
            It may converge on a good solution faster, or more slowly,
            and the fitness function may be good or poor at
            getting just the right mix of alleles.

            <br/><br/>

            Now, suppose we want to evolve yet another item.&nbsp;
            By the Rule of Three,
            it's about time we . . .
            TODO: MOVE EXTRACTION STUFF HERE!
          </aside>
        </section>

        <section>
          <img src="" class="autofix">
          <span class="slide-caption">Image: </span>
          <aside class="notes">
            In my spare time, I make . . .
          </aside>
        </section>

        <section>
          <img src="images/2021-06-12-Meads-Assembled.jpg" class="autofix" height="60%">
          <div class="main-text" style="font-size: 1.5em">
            Mead
            <br/></br><br/></br></br>
            (Hidromiel)
          </div>
          <span class="slide-caption">Image: my own pic of five batches of plain mead in progress</span>
          <aside class="notes">
            . . . mead,
            or in Spanish, "hidromiel",
            a wine-like drink made by fermenting honey.&nbsp;
            Let's see if we can evolve a good recipe.&nbsp;
            Our recipe will be based on two simple factors:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
class Recipe
  def initialize()
    # water:honey ratio ranges from 1.5-15
    @ratio = roll(3, 10) / 2.0
    # alcohol tolerance of 6-20
    @tolerance = 4 + roll(2, 8)
  end
end
            </pre>
          </div>
          <aside class="notes">
            the ratio of water to honey,
            and the alcohol tolerance of the yeast we'll use,
            both by volume.&nbsp;
            The more honey per volume,
            in other words the lower the ratio of water,
            the higher the level of alcohol you <i>could</i> get,
            <i>if</i> the yeast will tolerate that level of alcohol.&nbsp;
            Any leftover honey,
            that the yeast doesn't eat and convert into alcohol,
            is what makes the mead sweet.&nbsp;
            Those two resulting factors,
            the percent alcohol by volume, or ABV,
            and the sweetness,
            will be how we'll evaluate the recipe,
            but I'll spare you the details of how we figure them out.&nbsp;
            Of course we'll need a new . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
  def fitness()
    target_abv = 12
    target_sweet = 15
    abv, sweet = evaluate(self)
    abv_off = (target_abv - abv).abs
    sweet_off = (target_sweet - sweet).abs
    off = abv_off ** 2 + sweet_off ** 2
    100 - off;
  end</pre>
          </div>
          <aside class="notes">
            . . . fitness function.&nbsp;
            This one looks at how far off we are
            from our desired target values.&nbsp;
            We square the error in each aspect separately,
            so that something that's, say, one point off in each,
            will score higher than something that's spot-on in one
            but two points off in the other.&nbsp;
            In other words,
            we want them both close,
            not just trading off one for the other directly.

            <br/><br/>

            You can see here we are targeting 12% ABV,
            out of a range from 0 to 20,
            and 15 "points" of sweetness,
            which is on a custom scale . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <table>
              <tr><th>Level</th><th class="numeric">Min</th><th class="numeric">Max</th></tr>
              <tr><td>Dry</td><td class="numeric">0</td><td class="numeric">9</td></tr>
              <tr><td>Semi-Sweet</td><td class="numeric">10</td><td class="numeric">19</td></tr>
              <tr><td>Sweet</td><td class="numeric">20</td><td class="numeric">29</td></tr>
              <tr><td>Dessert</td><td class="numeric">30</td><td class="numeric">39</td></tr>
              <tr><td>Too Sweet</td><td class="numeric">40</td><td class="numeric"></td></tr>
              </tr>
            </table>
          </div>
          <aside class="notes">
            . . . of zero to about 80 for anything reasonable
            as a finished product.&nbsp;
            So we're going for roughly typical wine strength, and semi-sweet.

            <br/><br/>

            Of course there are a few other bits of code we'll need to change.&nbsp;
            For starters, the . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.1em">
            <pre>
  def self.combine(p1, p2)
    rec = self.new
    rec.ratio     = rand(2) == 1 ? p1.ratio     : p2.ratio
    rec.tolerance = rand(2) == 1 ? p1.tolerance : p2.tolerance
    return rec
  end

  def maybe_mutate()
    @ratio = maybe_mutate_stat(@ratio, 1.5, 15)
    @tolerance = maybe_mutate_stat(@tolerance, 6, 20)
  end</pre>
          </div>
          <aside class="notes">
            . . . breeding and candidate-mutation functions
            will only need to take care of two stats, instead of six,
            just like the candidate creation function.&nbsp;
            But . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
  def maybe_mutate_stat(stat, min, max)
    val = stat * (0.79 + roll(2, 20) / 100.0)
    return max if val &gt; max
    return min if val &lt; min
    return val
  end</pre>
          </div>
          <aside class="notes">
            . . . the generic stat mutator,
            and the calls to it from the candidate mutator,
            will be a bit more complex,
            as it needs to take different limits into account,
            and work well on differently-sized numbers.&nbsp;
            What this one does is
            to multiply by somewhere between 81% and 119%,
            so it's got very little chance of staying the same,
            and the difference will usually be rather small,
            since we're using multiple dice so we have a bell curve,
            but could go up to 19%.

            <br/><br/>

            Everything else, such as
            creating the initial population,
            selecting breeders,
            breeding a new population,
            the concept of how to check if we're done,
            though with a different threshold,
            and the overall structure of
            how it simulates evolution,
            all remain unchanged.

            <br/><br/>

            To demonstrate how this one runs, an initial population might look like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Ratio  Tolerance  %ABV  Sweet     Fit
 6.50       10.0   7.4    0.0  -145.8
 7.00       11.0   7.0    0.0  -150.3
 7.50        9.0   6.6    0.0  -154.6
 8.00       14.0   6.2    0.0  -158.7
 8.50       12.0   5.9    0.0  -162.6
 9.00       14.0   5.6    0.0  -166.2
 9.00        9.0   5.6    0.0  -166.2
12.50       11.0   4.1    0.0  -186.9
12.50       16.0   4.1    0.0  -186.9
13.00        9.0   4.0    0.0  -189.3
            </pre>
          </div>
          <aside class="notes">
            and the next generation like this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Ratio  Tolerance  %ABV  Sweet     Fit
 5.46       10.6   8.6    0.0  -136.3
 5.52       11.7   8.5    0.0  -136.9
 5.72        9.6   8.3    0.0  -138.7
 5.95        9.4   8.0    0.0  -140.8
 5.98       10.7   8.0    0.0  -141.1
 6.37       10.9   7.6    0.0  -144.6
 6.44       11.3   7.5    0.0  -145.2
 6.56       12.2   7.4    0.0  -146.4
 7.42        9.7   6.6    0.0  -153.9
 7.84        9.6   6.3    0.0  -157.4
            </pre>
          </div>
          <aside class="notes">
            . . . and after just 7 generations, finally this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Ratio  Tolerance  %ABV  Sweet     Fit
 3.46       10.4  10.4   16.4    95.2<span style="color:gray">
 3.59        9.9   9.9   17.4    89.5
 3.85        8.9   8.9   20.1    64.6
 3.42        9.7   9.7   22.5    38.1
 4.53        9.2   9.2    6.7    24.0
 3.50        9.2   9.2   24.4     4.6
 4.33        9.8   9.8    5.3     1.8
 3.94        7.7   7.7   27.1   -64.1
 4.33       11.0  10.5    0.0  -127.4
 3.53        8.3   8.3   30.6  -156.7</span>
            </pre>
          </div>
          <aside class="notes">
            with one candidate weaker and sweeter than we want,
            but within our 90%-fit criterion.&nbsp;
            If we get really picky and demand a 99.9% fit,
            my first run like that took 45 generations,
            and yielded this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Ratio  Tolerance  %ABV  Sweet     Fit
 3.05       11.8  11.8   15.2    99.9<span style="color:gray">
 3.21       10.9  10.9   18.2    88.7
 3.34       11.4  11.4   10.8    81.7
 3.28       10.5  10.5   19.2    79.8
 3.35       11.7  11.7    8.9    62.9
 3.31       11.8  11.8    8.8    61.4
 3.48        9.7   9.7   21.0    58.9
 3.05       13.1  13.1    4.9    -2.9
 3.60       11.8  11.8    2.6   -53.9
 3.68       12.2  11.9    0.0  -125.0</span>
            </pre>
          </div>
          <aside class="notes">
            . . . a tiny bit weaker and sweeter than asked for.&nbsp;

            <br/><br/>

            Just like with the DnD characters,
            if we want to change what we're after,
            we just have to tweak the fitness function.&nbsp;
            In this case we could even ask the user for the numbers,
            but I'll leave that as an exercise for you.&nbsp;
            Anyway, I asked for 7% alcohol and sweetness of 5,
            a low-alcohol dry mead, often called a "session" mead,
            and still demanding a 99.9% fit,
            it took 37 generations to get this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Ratio  Tolerance  %ABV  Sweet     Fit
 6.38        6.9   6.9    5.0   100.0<span style="color:gray">
 5.73        7.6   7.6    5.4    99.5
 5.32        8.2   8.2    4.9    98.6
 5.61        7.6   7.6    6.5    97.3
 6.25        6.7   6.7    7.8    92.2
 5.34        7.7   7.7    8.8    85.5
 5.23        8.8   8.8    1.0    80.7
 6.25        8.2   7.7    0.0    74.5
 6.02        8.3   7.9    0.0    74.1
 5.61        6.8   6.8   12.3    46.5</span>
            </pre>
          </div>
          <aside class="notes">
            . . . spot-on in sweetness and just a tiny bit weaker.&nbsp;
            Then I asked for 16% alcohol and a sweetness of 35,
            a strong and sweet mead,
            historically called sack mead or a great mead,
            a style very popular in Poland.&nbsp;
            It took 149 generations,
            which was still very fast,
            because the functions were so simple,
            to produce this:
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1.6em">
            <pre>
Ratio  Tolerance  %ABV  Sweet     Fit
 1.69       16.1  16.1   34.9   100.0<span style="color:gray">
 1.70       15.8  15.8   36.9    96.4
 2.06       13.6  13.6   35.2    94.3
 1.96       14.0  14.0   36.5    94.0
 1.94       15.4  15.4   27.3    39.9
 1.75       14.6  14.6   43.0    33.8
 1.92       13.3  13.3   43.8    16.1
 1.68       14.2  14.2   50.6  -146.3
 1.93       17.6  17.6   10.6  -497.1
 1.70       11.8  11.8   67.8  -992.7</span>
            </pre>
          </div>
          <aside class="notes">
            . . . just a tiny bit stronger and drier than asked for.

            <br/><br/>

            Now, just a little bit ago I said a lot of stuff was unchanged
            between these two usages,
            the DnD characters and the mead recipes.&nbsp;
            I usually wait until we have three,
            but let's pretend we have a third one.&nbsp;
            That means we should . . .
          </aside>
        </section>

        <section>
          <img src="images/tooth-extraction.png" class="autofix">
          <span class="slide-caption">Image: from https://www.authoritydental.org/tooth-extraction-recovery</span>
          <aside class="notes">
            . . . extract those part into something they all can use,
            something with a name like, oh, say, . . .
          </aside>
        </section>

        <section>
          <img src="images/evolver-license-plate.png" class="autofix">
          <span class="slide-caption">Image: my picture, of my actual license plate!</span>
          <aside class="notes">
            . . . Evolver!&nbsp;
            That's my actual license plate, by the way.&nbsp;
            I've had it for several years.

            <br/><br/>

            With just a little bit of tweaking,
            and a slight sprinkling of fancy Ruby magic dust,
            we can extract a class
            that will take another class
            that defines the necessary functions,
            and run evolution on it,
            like so:

          </aside>
        </section>

        <section>
          <div class="main-text">
            <pre style="font-size: .21em; line-height:1.1em">
class Evolver
  attr_reader :klazz, :header, :how_many

  def initialize(klazz, options={})
    @klazz = klazz
    @header = options[:header] || klazz::REPORT_HEADER rescue nil  # blank OK
    @how_many = options[:how_many] || 10
  end

  def evolve()
    pop = initial_population().sort_by(&:fitness).reverse
    generations = 1
    report(generations, pop)
    while not klazz.done?(pop, generations)
      breeders = klazz.select_breeders(pop)
      pop = breed(breeders)
      pop.each { |cand| cand.maybe_mutate }
      pop = pop.sort_by(&:fitness).reverse
      generations += 1
      report(generations, pop)
    end
  end

  def initial_population()
    (1..how_many).map { |_| klazz.new() }
  end

  def report(generations, pop)
    puts "After #{generations} generations:"
    puts header
    pop.each { |cand| cand.report() }
  end

  def breed(breeders)
    (1..how_many).map { |_| klazz.combine(breeders) }
  end
end
            </pre>
          </div>
          <aside class="notes">
            . . . and then our character and recipe classes
            can be shortened like so:
          </aside>
        </section>

        <section>
          <div class="main-text">
            <pre style="font-size: .1em; line-height:1.35em">
class Character
  REPORT_HEADER = "Str  Int  Dex  Con  Wis  Cha   Fit"
  attr_accessor :str, :int, :dex, :con, :wis, :cha, :fit

  def initialize()
    @str = roll(3, 6)
    @int = roll(3, 6)
    @dex = roll(3, 6)
    @con = roll(3, 6)
    @wis = roll(3, 6)
    @cha = roll(3, 6)
  end

  def roll(num_dice, die_size)
    (1..num_dice).map { rand(die_size) + 1 }.sum
  end

  def report
    printf(" %2d   %2d   %2d   %2d   %2d   %2d  %4d\n",
           str, int, dex, con, wis, cha, fit)
  end

  def self.done?(population, _generations)
    population.first.fitness &gt;= 1021
  end

  def fitness()
    stats = [int, wis, dex, con, cha, str]  # for wizards
    @fit = (0..5).map { |idx| stats[idx] * 2 ** (5 - idx) }.sum
  end

  def self.select_breeders(population)
    population.sort_by(&:fitness).reverse.take(2)
  end

  def self.combine(breeders)
    p1,p2 = breeders
    char = self.new
    char.str = rand(2) == 1 ? p1.str : p2.str
    char.int = rand(2) == 1 ? p1.int : p2.int
    char.dex = rand(2) == 1 ? p1.dex : p2.dex
    char.con = rand(2) == 1 ? p1.con : p2.con
    char.wis = rand(2) == 1 ? p1.wis : p2.wis
    char.cha = rand(2) == 1 ? p1.cha : p2.cha
    return char
  end

  def maybe_mutate()
    @str = maybe_mutate_stat(@str)
    @int = maybe_mutate_stat(@int)
    @dex = maybe_mutate_stat(@dex)
    @con = maybe_mutate_stat(@con)
    @wis = maybe_mutate_stat(@wis)
    @cha = maybe_mutate_stat(@cha)
  end

  def maybe_mutate_stat(stat)
    val = stat + rand(3) - 1
    return 18 if val &gt; 18
    return  3 if val &lt;  3
    return val
  end
end
            </pre>
          </div>
          <aside class="notes">
            and like so:
          </aside>
        </section>

        <section>
          <div class="main-text">
            <pre style="font-size: .1em; line-height:1.3em">
class Recipe
  REPORT_HEADER = "Ratio  Tolerance  %ABV  Sweet     Fit"
  attr_accessor :ratio, :tolerance, :abv, :sweet, :fit

  def initialize()
    @ratio = roll(3, 10) / 2.0
    @tolerance = 4 + roll(2, 8)
  end

  def roll(num_dice, die_size)
    (1..num_dice).map { rand(die_size) + 1 }.sum
  end

  def report
    printf("%5.2f       %4.1f  %4.1f   %4.1f  %6.1f\n", ratio, tolerance, abv, sweet, fit)
  end

  def self.done?(population, _generations)
    population.first.fitness &gt;= 99.9
  end

  def fitness()
    target_abv = 12
    target_sweet = 15
    @abv, @sweet = evaluate()
    abv_off = (target_abv - abv).abs
    sweet_off = (target_sweet - sweet).abs
    off = abv_off ** 2 + sweet_off ** 2
    @fit = 100 - off;
  end

  def evaluate()
    honey_volume = 1.0 / ratio
    total_mass = honey_volume * 1.425 + 1
    total_volume = honey_volume + 1
    og = total_mass / total_volume
    potential = (og - 1) * 1000 / 7.62
    abv = [tolerance, potential].min
    fg = og - abv * 7.62 / 1000
    return abv, (fg - 1) * 1000
  end

  def self.select_breeders(population)
    population.sort_by(&:fitness).reverse.take(2)
  end

  def self.combine(breeders)
    p1,p2 = breeders
    rec = self.new
    rec.ratio     = rand(2) == 1 ? p1.ratio     : p2.ratio
    rec.tolerance = rand(2) == 1 ? p1.tolerance : p2.tolerance
    return rec
  end

  def maybe_mutate()
    @ratio = maybe_mutate_stat(@ratio, 1.5, 15)
    @tolerance = maybe_mutate_stat(@tolerance, 6, 20)
  end

  def maybe_mutate_stat(stat, min, max)
    val = stat * (0.79 + roll(2, 20) / 100.0)
    return max if val &gt; max
    return min if val &lt; min
    return val
  end
end
            </pre>
          </div>
          <aside class="notes">
            . . . no I don't expect you to read that,
            let alone remember it,
            but the final slide . . .
          </aside>
        </section>

        <section>
          <div class="main-text" style="font-size: 1em">
            <h1>? ? ? ? ?</h1>
            <h5>
              www.Codosaur.us<br/>
              T.Rex-2022@Codosaur.us<br/>
              twitter.com/DaveAronson<br/>
              linkedin.com/in/DaveAronson<br/>
              <!-- toptal.com/#accept-only-candid-coders<br/> -->
              github.com/CodosaurusLLC/tight-genes</h5>
          </div>
          <aside class="notes">
            . . . has the URL for all the code,
            plus the HTML and images for the slides,
            complete with script.&nbsp;
            It's the last URL here, the one at Github.&nbsp;
            I'm going to ask that the editors
            leave the slide view visible
            during QnA,
            but just in case,
            you might want to take a screenshot now.
          </aside>
        </section>

      </div>
    </div>

    <script src="reveal/dist/reveal.js"></script>
    <script src="reveal/plugin/notes/notes.js"></script>
    <script src="reveal/plugin/markdown/markdown.js"></script>
    <script src="reveal/plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      const ratio = 9/16;
      const width = 960;
      Reveal.initialize({
        controls: false,
        hash: true,
        history: true,
        transition: "none",
        transitionSpeed: "fast",
        width: width,
        height: width * ratio,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
      });
      // Reveal.configure({ pdfMaxPagesPerSlide: 1, showNotes: 'separate-page' });
    </script>
  </body>
</html>
